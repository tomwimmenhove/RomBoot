// qemu-system-i386 -enable-kvm -cpu host -m 6G -net none -drive file=/mnt/wd500/images/windows.img,if=none,id=disk1 -device ide-hd,drive=disk1,bootindex=2 -option-rom rom_code.bin,bootindex=1

void putchar(c);
void setdateseg();
void int13();
int getcodeseg();
int getstackseg();
void hookint13();
int read(ax, cx, dx, es, bx, ds, si);
int old_addr, old_seg;
void call_old_int13();

void copy(src_seg, src_off, dst_seg, dst_off, len);

int cs, ss;
unsigned char hdd_num;

//#define NUM_HEADS (128)
//#define SECTS_PER_TRACK (32)
//#define NUM_CYL (1024)

#define NUM_HEADS (256)
#define SECTS_PER_TRACK (63)
#define NUM_CYL (1024)

//extern int oldint13seg;
//extern int oldint13addr;

//#define MK_FP(s,o) ((void far *)(((unsigned long)(s)<<16)|(unsigned)(o)))

#if 0
unsigned char bootsect_bin[] = {
  0xfa, 0xbe, 0x10, 0x7c, 0xb4, 0x0e, 0xac, 0x08, 0xc0, 0x74, 0x04, 0xcd,
  0x10, 0xeb, 0xf7, 0xf4, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
  0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
};

unsigned int bootsect_bin_len = 512;
#endif

void puts(s)
char* s;
{
	while (*s)
	{
		putchar(*s);
		s++;
	}
}

void printhex8(num)
unsigned char num;
{
    int i;
    unsigned char hexDigit;

    for (i = 0; i < 2; i++) {
        hexDigit = num >> 4;;
        if (hexDigit < 10) {
            putchar('0' + hexDigit);
        } else {
            putchar('A' + hexDigit - 10);
        }

	num <<= 4;
    }
}

void printhex(num) {
    printhex8(num >> 8);
    printhex8(num & 0xff);
}

struct extended_read
{
	unsigned char dap_size;
	unsigned char unused0;
	unsigned int n_sectors;
	unsigned int ptr_offset;
	unsigned int ptr_segment;
	unsigned char sector_starts[8];
};

	char s1[10];
	char s2[10];
	struct extended_read er;
	char buf[16];

#define STC f |= 1
#define CLC f &= ~1

struct
{
	unsigned char dap;
	unsigned char zero;
	unsigned int n;
	unsigned int offset;
	unsigned int seg;
	unsigned int lba0;
	unsigned int lba1;
	unsigned int lba2;
	unsigned int lba3;
} ext_read_packet;

unsigned int read_sectors(lba, seg, offs, n_sect)
	unsigned int lba;
	unsigned int seg;
	unsigned int offs;
	unsigned char n_sect;
{
#if 0
	copy(cs, bootsect_bin, seg, offs, n_sect * 512);
#else
	ext_read_packet.dap = 0x10;
	ext_read_packet.zero = 0;
	ext_read_packet.n = n_sect;
	ext_read_packet.seg = seg;
	ext_read_packet.offset = offs;
	ext_read_packet.lba0 = lba & 0xffff;
	ext_read_packet.lba1 = (lba >> 16) & 0xffff;
	ext_read_packet.lba2 = 0;
	ext_read_packet.lba3 = 0;

	return read(0x4200, 0, 0x0081, 0, 0, cs, &ext_read_packet);
#endif
/*
	unsigned int c = lba / SECTS_PER_TRACK / NUM_HEADS;
	unsigned int h = (lba / SECTS_PER_TRACK) % NUM_HEADS;
	unsigned int s = (lba % SECTS_PER_TRACK) + 1;

	unsigned int cx = c << 6 | s;
	unsigned int dx = h << 8 | 0x80;
	c = 0;
	h = 1;
	s = 1;

	cx = c << 6 | s;
	dx = h << 8 | 0x80;

	puts("c="); printhex(c);
	puts(", h="); printhex(h);
	puts(", s="); printhex(s);
	puts("\r\n");
			
	return read(0x0200 | n_sect, cx, dx, seg, offs);
*/
}

int force_chain;

unsigned char bs_buf[512];

unsigned char get_num_drives()
{
	unsigned char n;

	copy(0x0040, 0x0075, ss, &n, 1);
	return n;
}

void set_num_drives(n)
unsigned char n;
{
	copy(ss, &n, 0x0040, 0x0075, 1);
}

/* Registers are popped back off the stack after calling this function
 * which means you can alter them by simply writing to them */
void int13handler(f, di, si, bp, bx, dx, cx, ax, es, ds)
{
	unsigned char al = ax & 0xff;
	unsigned char ah = ax >> 8;
	unsigned char dl = dx & 0xff;
	unsigned char n;
	int x = int13handler;
	int i;
	int tmp;

	if (force_chain)
	{
		STC;
		return;
	}

#if 1
	n = get_num_drives();
	puts("Number of drives at int13: ");
	printhex8(n);
	puts("h\r\n");

	puts("\r\ndx=");
	printhex(dx);
	puts(", ax=");
	printhex(ax);
	puts("\r\n");
#endif

	if ((dx & 0xff) != hdd_num)
	{
		STC;
		return;
	}
//	puts("fart\r\n");

	switch (ax >> 8)
	{
		case 0x08: // Get geometry
		{
			CLC;
			ax &= 0x00ff;
			dx = (dx & 0x00ff) | ((unsigned char) NUM_HEADS - 1) <<8;
			cx = ((NUM_CYL - 1) << 6) | SECTS_PER_TRACK;
			bx &= 0xff00;
			return;
		}
		case 0x02: // Read sectors
		{
			unsigned char n = ax & 0xff;
			unsigned int c = cx >> 6;
			unsigned char h = dx >> 8;
			unsigned char s = cx & 0x3f;

			// XXX: Need 32-bit operation support!
//			unsigned long int lba = (((unsigned long int) c << 7) + ((unsigned long int) h)
//				<< 5) + (s - 1);
			unsigned int lba = ((((unsigned int) c * NUM_HEADS) + ((unsigned int) h)) * SECTS_PER_TRACK) + (s - 1);

			if (lba > 0)
			{
				// effectively 'unhook'
				//force_chain = 1;
			}

			puts("n="); printhex(n);
			puts("\r\n");

			puts("ch="); printhex8(cx >> 8);
			puts(", cl="); printhex8(cx);
			puts(", dh="); printhex8(dx >> 8);
			puts("\r\n");
			
			puts("c="); printhex(c);
			puts(", h="); printhex(h);
			puts(", s="); printhex(s);
			puts("\r\n");
			
			puts("lba=");
//			printhex(lba >> 16);
			printhex(lba);
			puts("\r\n");

			tmp = read_sectors(lba, es, bx, n);
			//tmp = read_sectors(lba, cs, bs_buf, 1);
			//copy(cs, bs_buf, es, bx, 512);
			ax = 0x0001;

			puts("tmp: ");
			printhex(tmp);
			puts("\r\n");

#if 0
			copy(es, bx, cs, bs_buf, 512);
			for (i = 0; i < 10; i++)
			{
				printhex(i);
				putchar(';');
				printhex8(bs_buf[i]);
				puts("\r\n");
			}
#endif

#asm
;hlt
#endasm

			CLC;
			break;
		}

		case 0x41: // Extensions present
		{
			if (bx != 0x55aa)
			{
				puts("Unsupported bx=");
				printhex(bx);
				puts("\r\nHalted.");
				#asm
					hlt
				#endasm
				break;
			}
			CLC;
			ax = 0x0100; // v1.x (??) (see https://mybogi.files.wordpress.com/2011/08/interrupt-13h.pdf)
			//ax = 0x0000;
			cx = 1; // Device Access using the packet structure
		}

		case 0x42: // Read sectors extended
		{
			unsigned int lba;
			copy(ds, si, cs, &ext_read_packet);

			lba = ext_read_packet.lba0 | ext_read_packet.lba1 << 16;
			tmp = read_sectors(lba, ext_read_packet.seg, ext_read_packet.offset, ext_read_packet.n);

			puts("tmp: ");
			printhex(tmp);
			puts("\r\n");

			ax = 0x0000;
			CLC;
			break;
		}

		default:
			puts("Unsupported ah=");
			printhex(ax >> 8);
			puts("\r\nHalted.");
			#asm
				hlt
			#endasm
			break;
	}

	return;
}

void kernel_init()
{
	char n;

	n = get_num_drives();
	puts("Number of drives at init: ");
	printhex8(n);
	puts("h\r\n");
}

/* TODO:
 * From https://www.scs.stanford.edu/nyu/04fa/lab/specsbbs101.pdf
 *   A controller checks if the location at 0040:0075 is zero to determine if it is the first
 *   to install. If it is first, the controller must copy the INT 13h vector over the INT
 *   40h vector so that floppy services are handled properly.
 */
int kernel_main()
{
	char n;

	cs = getcodeseg();
	ss = getstackseg();

	n = get_num_drives();
	hdd_num = 0x80 + n;
	puts("Number of drives before hook: ");
	printhex8(n);
	puts("h -- Registering hard drive number ");
	printhex8(hdd_num);
	puts("h\r\n");

	set_num_drives(n + 1);

	hookint13();
	force_chain = 0;
}

